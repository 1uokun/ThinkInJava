# 第1章 面试的流程
如果应聘者在面试的时候**没有听清**或者**没有听懂**面试官的问题时，
千万不要不懂装懂、答非所问。一定要大胆地向面试官多提问，直到弄清楚面试官的意图为止。
敢于说Pardon(对不起)

 - 自我介绍
    
     用30秒到1分钟的时间介绍自己的主要学习、工作经历即可
 
 - 项目经验 (STAR模型)
    - Situation:简短的项目背景，比如项目的规模，开发的软件的功能、目标用户等。
    - Task:自己完成的任务。负责了什么，参与了什么
    - Action:为了完成任务自己做了哪些工作，是怎么做的
    - Result:自己的贡献。这个一定要具体、量化（最好用数字加以说明）
 
 - 你在该项目中碰到的最大的问题是什么，你是怎么解决的？
 
 - 从这个项目中你学到了什么？
 
 - 什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）
   
   有什么样的冲突，你们是怎么解决冲突的？
 
 - 🌟回答"为什么跳槽"
    
    尽量避免以下4个原因
    - 老板太苛刻
    - 同事太难相处
    - 加班太频繁
    - 工资太低
    
    🚩参考答案：
    1. 我在xx开发一款面向xx的软件，如果我想在现在的职位上得到提升，就必须加强
    xx行业的学习，可是我对xx等没有太多兴趣，因此出来寻找机会。
    2. 主要维护xx非常成熟的平台，因此平时工作主要是维护和修改BUG，在xx方向得到
    很大的提高，但长期如此在xx上得不到提高，因此想出来寻找可以xx的职位。众所周知，
    贵公司在xx方向上行业佼佼者，因此对贵公司很感兴趣。
    
 - 💪技术面
 
    - 清晰的思路
    - 优化效率的能力
    
      面试官出的题目有多种解法的时候，通常他会期待应聘者最终能够找到最优解。
      应聘者应该在时间消耗或空间消耗上对比优化。
      要想优化**时间效率**或者**空间效率**，首先要知道如何分析效率。
      优化代码的效率，还要熟知各种数据结构的优缺点以及常用的算法。
    - 优秀的综合能力（沟通能力、学习能力、知识迁移能力）
    
 - 应聘者提问环节
    - 不要问薪水，要谈工资要等通过面试之后和HR谈。
    - 不要立即打听面试结果
    
    🚩参考答案：
    1. 内部培训，是否有机会去总公司内部学习
    2. 对职位相关的硬性要求和其他软技能有什么要求
    

# 第2章 面试需要的基础知识

## 面试题1：赋值运算符函数
考察异常安全性(Exception Safety)原则
有两种方法：
 1. 先用`new`分配新内容再用`delete`释放已有的内容
 2. 创建一个临时实例`strTemp`，接着与实例自身来回替换
    ES6有优化`[a,b] = [b,a]`
    
## 面试题2：实现Singleton模式
单线程 按需创建实例
```java
public class CrimeLab {
    private static CrimeLab sCrimeLab;

    public static CrimeLab get(Context context){
        if(sCrimeLab == null){
            sCrimeLab = new CrimeLab(context);
        }
        return sCrimeLab;
    }
    
    private CrimeLab(Context context){
        // 业务代码
    }
}
```

## 面试题3：二维数组中的查找
> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，
> 每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一
> 个二维数组和一个整数，判断数组中是否含有该整数。

 - 考察二维数组的理解及编程能力
 - 考察分析问题的能力。遇到问题比较复杂时，
 能不能通过具体的例子来找出其中的规律。
 
 这道题就是**从右到左**递减找出存在的那一列，
 然后**从上到下**递增定位到那一列的这一行，如果没有就重复上述**再从右到左**
 
 ⚠️测试用例：
 - 二维数组中没有查找的数字（为递归做及时退出保护）
 - 特殊输入测试（输入空指针）
 
## 面试题4：替换空格
> 题目：请实现一个函数，把字符串中的每个空格替换成"%20"。
> 例如输入"We are happy"，则输出"We%20are%20happy"。

 - 时间复杂度为**O(n^2)**的解法
 
    从左往右循环找出空格并依次替换，
    这样会导致每次找出并替换时，后面的字符都需要要向右位移"%20"三个格子
    
 - 时间复杂度为**O(n)**的解法
 
 第一次出现双指针
 
    1. 先遍历一次字符串（这样就能统计出字符串中空格的总数，并计算替换后字符串的长度）
    2. 准备两个指针P1和P2(本书第一次出现的**双指针解法**，后面还有很多问题可以利用**双指针解法**优化)
    3. P1指向字符串的末尾，P2指向替换后的字符串的末尾（空格总数乘以替换后的长度差）
    4. P1向左移动，逐个把碰到的字符串复制给P2的位置。碰到第一个空格时，再向P2传输"%20"3个字符串，
       然后p2移动到"%"之前的空格处。
    5. 重复第3步和第4步
    
 ⚠️测试用例：
  - 输入的字符串没有空格
  - 特殊输入测试（字符串是个NULL指针、空字符串、只有一个空字符、字符串中只有连续多个空格）
 
 🚩举一反三：
  - 合并两个数组
    
    如果从前往后复制每个数字，需要重复移动数字多次<br/>
    我们可以考虑从后往前复制，这样能减少移动的次数
    
## 面试题5：从尾到头打印链表
> 题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。

回答问题之前，大胆问面试官**是否允许在打印链表的时候修改链表的结构？**
   - 如果可以改变（一般打印是一个只读操作），遍历一遍，将next值改成前一个
     再遍历一遍被改后的链表
   - 如果不可以改变，典型的"后进显出"，所以需要额外空间-栈，每经过一个结点的时候，把这个结点放到栈中，
     遍历完链表后，再遍历一遍栈
   - 利用递归的调用栈特性<br/>
     递归遍历链表，然后打印每一个next，输出顺序自然是从底层往上输入
     
  ⚠️测试用例：
   - 功能测试（输入的链表有多个结点、一个结点）
   - 特殊输入测试（链表表头结点指针为NULL）
   
  🚩本题考点：
   - 单向链表的理解和编程能力
   - 循环、递归和栈 三个概念的理解

## 面试题6：重建二叉树
> 题目：输入某二叉树的**前序遍历**和**中序遍历**结果，请重建该二叉树。
> 假设都不存在重复的数字。
> 如前序遍历结果{1,2,4,7,3,5,6,8}和中序遍历结果{4,7,2,1,5,3,8,6}

```
        1
       2  3
     4   5 6
      7     8
```
解法：从前序中获得根结点
在中序中以该结点，获得左和右结点
重复上述


1为根结点，中序可分为{4,7,2}和{5,3,8,6}
中序{5,3,8,6}中因为前序{3,5,6,8}所以3为根结点,5在左边
中序{6,8},前序{6,8}，6为根结点，8在6的右边

  🚩本题考点：
   - 前序遍历： 根 > 左 > ~ > 左 > 右 (特点：第一个永远为根结点，如果是二叉搜索树的话就是一个顺序递增的结果)
   - 中序遍历： 左 > 根 > 右 > 根（在已知根结点的情况下，左结点永远为左，右结点永远在右）
   - 后序遍历： 左 > 右 > 根（深度优先遍历，特点：最后一个永远为根结点）

## 面试题7：用两个栈实现队列
  🚩本题考点：
   - 栈Stack：先进后出
   - 队列Queue：先进先出
   - 拓展：用两个队列实现一个栈
   
## 面试题8：旋转数组的最小数字 - 二分查找
> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为**数组的旋转**。
> 输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如[3,4,5,1,2]为
> [1,2,3,4,5]的一个旋转，该数组的最小值

 - O(n)解法，从头到为遍历一遍
 - O(log n)解法（利用双指针实现二分查找）
   
   第一个指针P1指向第一个元素，第二个指针P2指向最后一个元素
   如果中间的数字比P1大，比P2小，将P1移动到中间的数字
   如果中间的数字比P1小，比P2大，将P2移动到中间的数字
   直到P1与P2相邻时，P2所指的数字就是最小的数字
   
## 面试题9：斐波那契数列

 - O(n)
  ```
  f(n) = f(n-1)+f(n-2)
  ```
 - O(log n)
  生僻公式

## 面试题10：二进制中1的个数 - 位与运算
> 题目：请实现一个函数，输入一个整数，输出该树二进制表示中1的个数。
> 例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

 - 常规解法：先转成二进制，从右往左循环，是1就自增
 - 位与运算(相同的返回1，不相同的返回0)：
   第一步：一个整数和它减去1的结果做位与运算；
   记录次数+1；
   第二步：再把这个整数和第一步返回的结果做**位与运算**
   ```
    int NumberOf1(int n){
       int count = 0;
   
       while(n){
         ++count;
         n = (n - 1) & n;
       }
   
       return count;
    }
   ```
  
  ⚠️测试用例：
   - 正数（包括边界值1、0x7FFFFFFF）
   - 负数
   - 0
  
  🚩本题考点：
   - 考查 二进制和位运算 的理解
   - 考查分析、调试代码的能力（如出现负数时会出现死循环）
   
  ❓举一反三：
   - 只用**一条语句**判断一个整数是不是2的整数次方。
    （如果是那么二进制，那么只会有1个1，所以 `(n & (n-1)) === 0`）

# 第3章：高质量的代码

> *"我会从程序的**正确性**和**鲁棒性**两方面检验代码的质量。会关注*
> *对 **输入参数的检查**、**处理错误和异常的方式**、**命名方式**等。对于没有工作*
> *经验的学生，程序正确性之外的错误基本能容忍，但经过提示后希望*
> *能够很快解决。**对于有工作经验的人，不能容忍考虑不周到、有明显鲁棒性错误。**"*

## 面试题11：数值的整数次方
> 题目：实现函数 double Power(double base,int exponent)，求base的
> 指数(exponent)次方。不得使用库函数(如`pow(b,e)`)，同时不需要考虑大数问题。

 - 自以为题目简单的解法：循环exp，然后base自乘
   没有考虑到exp的正负
 - 考虑代码完整性：（功能测试、边界测试、负面测试3个方面设计测试用例）、
   以及错误处理（返回值、全局代码和异常），如`0的0次方应该返回多少`、
   最小边界值是多少`0.00000001`(还会由于精度原因不能用等号判断两个小数是否相等)
 - 全面又高效的解法：代码完整性后，还要提高效率。
   循环乘法自增会重复计算，可以应用斐波那契数列递归来优化重复计算，
   如32次方 等于 16次方再2次方法，我们已经知道16次方的值，直接2次方即可获得结果
   ```
   // n为偶数
   a^n = a^(n/2) * a^(n/2)
   
   // n为奇数
   a^n = a^[(n-1)/2] * a^[(n-1)/2] * a
    
   ```
  ⚠️测试用例：
   - 把底数和指数分别设为正数、负数和零
   
  🚩本题考点：
   - 考查思维的全面性。问题本身不难
   - 将效率提高到极致：位运算比乘除运算以及求余运算效率高得多

## 面试题12：打印1到最大的n位数 - 🎰
> 题目：输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，
> 则打印出1、2、3一直到最大的3位数即999。

 - 在字符串上模拟数字加法的解法：
   考虑到"大数问题"（int自增到long时会溢出），用字符串模拟。
   如打印到5位数时，从"00001"、"00002"一直到"99999"。再额外加一个函数
   只打印碰到第一个非0的字符
 - 把问题转换成数字排列的解法，递归让代码更简洁
   上一个解法很难在短时间内写完。既然都是要从0自增到9，
   不如用递归在每一个位数字进行递归（有点像老虎机🎰）
   
## 面试题13：在O(1)时间删除链表结点
> 题目：给定单向链表的头指针和一个结点指针，定义一个函数在O(1)
> 时间删除该结点。

 - 关键词不在delete。将上一个结点的next指定到需要被删除结点的next，
   该结点自动脱离了链表
   
  ⚠️测试用例：
   - 功能测试（删除尾结点、删除唯一结点、删除头结点）
   - 特殊输入测试（NULL指针）
  
  🚩本题考点：
   - 考查对链表的编程能力
   - 考查创新思维能力（DO NOT FOCUS delete）
   - 老规矩，思维的全面性，代码的鲁棒性完整性。
   
## 面试题14：调整数组顺序使奇数位于偶数前面 - 拓展性
> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，
> 使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

 - 只完成当前的基础功能的解法，仅适用于初级程序员
   没有额外的空间，使用双指针。指针A指向第一个，指针B指向最后一个。
   移动A指针，发现是奇数，继续移动；发现是偶数，关注点来到B，如果是奇数和A交换，如果是偶数，向前移动
 - 考虑可扩展性的解法：如果条件从奇偶数换成"能否被3整除"或者其他方法怎么办？
   1.将指针移动和交换的条件分离出来 做一个boolean函数
   2.（效率较低）在JavaScript中添加一个额外的空间，使用foreach将抽离的条件带入进去
     将符合条件的push到额外空间中，原数组splice操作。循环结束后，再push原数组剩下的
     
   🚩本题考点：
    - 代码的扩展性、可重用性
    
    
## 面试题15：链表中倒数第k个结点 - 鲁棒性
> 题目：输入一个链表，输出该链表中倒数第k个结点。

 - 从头到尾遍历一遍链表，获得链表长度l。再从l-k开始遍历到最后。
   缺点：时间效率低（要遍历2次链表）、鲁棒性差（循环链表怎么办）
 - 双指针只循环一次：p1、p2都在起点；p2保持不动，p1向前走k-1；
   p1到达后，p1、p2联动向前。当p1到达尾部时，p2刚好指向第k个结点。
   
   ⚠️测试用例：
    - 功能测试（k结点在表头、k结点在链表中间、k结点在表尾）
    - 特殊输入测试（NULL 、链表的结点总数小于k）
    
   🚩本题考点：
    - 考查对链表的理解
    - 考查代码的鲁棒性（鲁棒性，Robust的音译，有时也翻译成健壮性）。容错性是鲁棒性
      的一个重要体现。

## 面试题16：反转链表 - 指针操作容易出错
> 题目：定义一个函数，输入一个链表的头结点，反转该链表并输出
> 反转后链表的头结点。

 - 解决与链表相关的问题总是有大量的指针操作，而指针操作的代码总是容易出错的。
 - 用递归实现反转链表的功能
 
    ⚠️测试用例：
     - 输入的链表头指针是NULL
     - 输入的链表只有一个结点
     - 输入的链表有多个结点
     
## 面试题17：合并两个排序的链表
> 题目： 1->3->5->7->9 和 2->4->6->8 合并成
> 1->2->3->4->5->6->7->8->9

## 面试题18：树的子结构
> 题目：输入两棵二叉树A和B，判断B是不是A的子结构。

 - 和链表相比，树中的指针操作更多也更复杂。
 - 个人解法：中序遍历和前序遍历。然后找数组Aarr中有没有Barr片段




   🚩本章考点
    - 规范性
      书写清晰、布局清晰、命名规范
    - 完整性
      完成基本功能、考虑边界条件、做好错误处理
    - 鲁棒性
      采取防御式编程、处理无效的输入
      
# 第4章 解决面试题的思路

> 画图让抽象问题形象化

## 面试题19：二叉树的镜像

## 面试题20：顺时针打印矩阵

```
1  2  3   4
5  6  7   8
9 10  11 12
```
输出结果 1、2、3、4、8、12、11、10、9、5、6、7

> 举例让抽象问题具体化

## 面试题21：包含min函数的栈
> 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小
> 元素的min函数。在该栈中，调用min、push及pop的时间复杂度都是O(1)。

